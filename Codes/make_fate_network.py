#!/usr/bin/python

import math,sys,os
import numpy as np
from decimal import *

#Decimal precision, don't remember the reason for setting this
getcontext().prec = 7

if len(sys.argv) < 3:
	print("Input error.\nUsage: make_fate_network.py [counts.pts] [network.fnet]")
	sys.exit(1)
else:
	data = sys.argv[1]
	output_network = sys.argv[2]

#Below the main body of the code. It basically reads in the patterns generated by count_sequence_patterns.py and then calculates network edges from these. One note is that {family}.pts contains all species-vs-species comparisons (the full matrix), whereas we here just infer the half matrix (we track when we can skip lines).

count_lines = 0
with open(data, 'r') as fin:
	for line in fin:
		count_lines += 1
		if count_lines == 1:
			skip_lines = 0
			start = 1
			skipped = 0
			remember = ""
		word=line.split()
		if word[0] != remember and start == 0:
			skip_lines += 1
			skipped = 1
			remember = word[0]
		elif skipped < skip_lines:
			skipped += 1
		else:
			x1_label = word[0]
			x2_label = word[1]
			y1_label = word[2]
			y2_label = word[3]
			OOOO = int(word[4])
			OOOA = int(word[5])
			OOAO = int(word[6])
			OOAA = int(word[7])
			OOAB = int(word[8])
			OAOO = int(word[9])
			OAOA = int(word[10])
			OAOB = int(word[11])
			OAAO = int(word[12])
			OABO = int(word[13])
			OAAA = int(word[14])
			OAAB = int(word[15])
			OABA = int(word[16])
			OABB = int(word[17])
			OABC = int(word[18])
			AOOO = int(word[19])
			AOOA = int(word[20])
			AOOB = int(word[21])
			AOAO = int(word[22])
			AOBO = int(word[23])
			AOAA = int(word[24])
			AOAB = int(word[25])
			AOBA = int(word[26])
			AOBB = int(word[27])
			AOBC = int(word[28])
			AAOO = int(word[29])
			ABOO = int(word[30])
			AAOA = int(word[31])
			AAOB = int(word[32])
			ABOA = int(word[33])
			ABOB = int(word[34])
			ABOC = int(word[35])
			AAAO = int(word[36])
			AABO = int(word[37])
			ABAO = int(word[38])
			ABBO = int(word[39])
			ABCO = int(word[40])
			AAAA = int(word[41])
			AAAB = int(word[42])
			AABA = int(word[43])
			AABB = int(word[44])
			AABC = int(word[45])
			ABAA = int(word[46])
			ABAB = int(word[47])
			ABAC = int(word[48])
			ABBA = int(word[49])
			ABCA = int(word[50])
			ABBB = int(word[51])
			ABBC = int(word[52])
			ABCB = int(word[53])
			ABCC = int(word[54])
			ABCD = int(word[55])
			remember = x1_label
			start = 0

			Fate_ABAB = OAOA+AOAO+AOAB+ABAO+ABAB+ABAC+OABA+ABOB+ABCB+OAOB+AOBO	#Or for awk-usage in bash: 11+23+26+39+48+49+17+35+54+12+24
			Fate_ABBA = OAAO+AOOA+AOBA+ABOA+ABBA+ABCA+OAAB+ABBO+ABBC+OABO+AOOB	#Or for awk-usage in bash: 13+21+27+34+50+51+16+40+53+14+22
			Fate_AABB = OOAA+OOAB+OABB+AOBB+AAOO+ABOO+AAOB+AABO+AABB+AABC+ABCC	#Or for awk-usage in bash: 8+9+18+28+30+31+33+38+45+46+55

			# Warn if no informative positions were found.
			if Fate_ABAB + Fate_ABBA + Fate_AABB == 0:
				print("### Warning: no informative positions in this case.")
				Convergence = 0
				Divergence = 0

			else:
				Convergence = abs(Fate_ABAB-Fate_ABBA)/float(Fate_ABAB+Fate_ABBA+Fate_AABB)
				Divergence = Fate_AABB/float(Fate_ABAB+Fate_ABBA+Fate_AABB)

			if Fate_ABAB > Fate_ABBA:
				with open(output_network, 'a') as fout:
					fout.write(x1_label+" "+str(Convergence)+" "+y1_label+"\n"+x2_label+" "+str(Convergence)+" "+y2_label+"\n")
			elif Fate_ABBA > Fate_ABAB:
				with open(output_network, 'a') as fout:
					fout.write(x1_label+" "+str(Convergence)+" "+y2_label+"\n"+x2_label+" "+str(Convergence)+" "+y1_label+"\n")
